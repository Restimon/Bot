# combat.py
from __future__ import annotations

import random
import math
import asyncio
from typing import Dict, Any, Optional, Tuple, List

from inventory import remove_item, add_item, get_item_qty
from stats_db import (
    deal_damage,
    heal_user,
    add_shield,
    get_hp,
    is_dead,
    revive_full,
    get_shield,
)
from effects_db import (
    add_or_refresh_effect,
    transfer_virus_on_attack,
    _pack_meta,
    has_effect as has_status,
    remove_effect as remove_status,
)
from ravitaillement import OBJETS, GIFS  # tu m'as dit que le fichier s'appelle ravitaillement.py
from passifs import (
    get_equipped_code,
    # ---- Hooks passifs (noms √† adapter si besoin) ----
    crit_multiplier_against_defender_code,    # e.g. Zeyra : 0.5
    get_extra_dodge_chance,                   # bonus d‚Äôesquive c√¥t√© d√©fenseur (%, 0..1)
    get_extra_reduction_percent,              # r√©duction suppl√©mentaire c√¥t√© d√©fenseur (0..1)
    maybe_preserve_consumable,                # True => ne consomme pas l‚Äôobjet
    king_execute_ready,                       # True si 'Le Roi' ex√©cute √† 10 PV
    valen_reduction_bonus,                    # % de r√©duction dynamique quand <50% PV
    undying_zeyra_check_and_mark,             # retourne True si ‚Äúsauvegard√©e √† 1 PV‚Äù (consomme le charge/jour)
    on_attack_after,                          # triggers post-attaque (loot, heal on hit, etc.)
    on_heal_after,                            # triggers post-heal (gain PB etc.)
    on_use_after,                             # triggers post-use (si tu en as besoin)
    bonus_damage_vs_infected,                 # e.g. Kevar Rin : +3 dmg vs infect√©s
)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# R√©glages globaux
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
BASE_CRIT_MULT = 2.0             # crit x2
ATTACK_DODGE_IMMUNE_LABEL = "üëü Esquive !"
IMMUNITY_LABEL = "‚≠ê Immunit√©"
COLOR_ATTACK = 0xED4245
COLOR_HEAL = 0x57F287
COLOR_USE = 0xFEE75C

# Pour infection ‚Äúcontagion‚Äù lors d‚Äôune attaque
INFECTION_PROPAGATE_CHANCE = 0.25

# Poison : malus -1 dmg pour l‚Äôattaquant
POISON_OUTGOING_PENALTY = 1

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Utils locaux
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

def _clamp(n: float, a: float, b: float) -> float:
    return max(a, min(b, n))

async def _current_esquive_chance(defender_id: int) -> float:
    """
    Esquive totale du d√©fenseur :
      - Bonus de statut 'esquive' (effects_db)
      - Bonus passif (e.g. Nova Rell +5%)
      - Stacks temporaires (e.g. Neyra) -> suppos√© stock√©s dans effects_db sous 'esquive'
    """
    base = 0.0
    eff = await has_status(defender_id, "esquive")
    if eff:
        # on lit la valeur via get_effect si besoin ; ici on suppose get_extra_dodge_chance ajoute ce qui manque
        pass
    extra = await get_extra_dodge_chance(defender_id) or 0.0
    return _clamp(base + extra, 0.0, 0.95)

async def _current_reduction_percent(defender_id: int) -> float:
    """
    R√©duction totale (ne s‚Äôapplique PAS aux DOT ‚Äî d√©j√† g√©r√© dans effects_db).
    Sources :
      - effets: reduction / reduction_temp / reduction_valen (en %)
      - passifs (e.g. bonus passif fixe, paliers Valen)
    """
    base = await get_extra_reduction_percent(defender_id) or 0.0
    base += await valen_reduction_bonus(defender_id) or 0.0
    # clamp prudent
    return _clamp(base, 0.0, 0.90)

async def _is_immune(defender_id: int) -> bool:
    """Immunit√© bloque enti√®rement les d√©g√¢ts directs (et les DOT c√¥t√© effects_db)."""
    return await has_status(defender_id, "immunite")

async def _apply_direct_damage(attacker_id: int, defender_id: int, raw_damage: int) -> Dict[str, Any]:
    """
    Applique des d√©g√¢ts **directs** avec r√®gles :
      - esquive (tout √©vite) ‚Äî pas pour DOT
      - immunit√© (tout bloque) ‚Äî pas pour DOT (g√©r√© dans effects)
      - r√©duction (%), puis deal_damage (qui g√®re PB -> PV)
    Retourne un dict: {'dmg_in': raw, 'dmg_after_reduc': x, 'absorbed': y, 'lost': z, 'dodged': bool, 'immune': bool, 'ko': bool}
    """
    # Esquive ?
    dodge_chance = await _current_esquive_chance(defender_id)
    if random.random() < dodge_chance:
        return {"dmg_in": raw_damage, "dmg_after_reduc": 0, "absorbed": 0, "lost": 0, "dodged": True, "immune": False, "ko": False}

    # Immunit√© ?
    if await _is_immune(defender_id):
        return {"dmg_in": raw_damage, "dmg_after_reduc": 0, "absorbed": 0, "lost": 0, "dodged": False, "immune": True, "ko": False}

    # R√©duction (%)
    reduc = await _current_reduction_percent(defender_id)
    eff_damage = max(0, int(round(raw_damage * (1.0 - reduc))))

    # Appliquer d√©g√¢ts (deal_damage g√®re PB->PV + stats + coins)
    res = await deal_damage(attacker_id, defender_id, eff_damage)  # res: {'absorbed': X, 'lost': Y}
    ko = await is_dead(defender_id)

    return {
        "dmg_in": raw_damage,
        "dmg_after_reduc": eff_damage,
        "absorbed": res.get("absorbed", 0),
        "lost": res.get("lost", 0),
        "dodged": False,
        "immune": False,
        "ko": ko,
    }

def _roll_crit(base_chance: float, defender_code: Optional[str]) -> float:
    """
    D√©termine crit: True/False. Puis retourne multiplicateur (1.0 ou 2.0 x modif Zeyra).
    - Zeyra (Volont√© de Fracture üí•) : crit divis√©s par 2 ‚Üí on ajuste le multiplicateur via passif helper
    """
    if base_chance <= 0:
        return 1.0
    if random.random() >= base_chance:
        return 1.0
    mult = BASE_CRIT_MULT
    # Ajustements c√¥t√© d√©fenseur (ex: Zeyra: *0.5)
    if defender_code:
        mult *= crit_multiplier_against_defender_code(defender_code) or 1.0
    return mult

async def _consume_item_if_needed(user_id: int, item_key: str) -> bool:
    """Consomme l‚Äôobjet √† la fin de l‚Äôaction, sauf si passif 'ne consomme pas' s‚Äôactive."""
    preserve = await maybe_preserve_consumable(user_id, item_key)
    if preserve:
        return False  # pas consomm√©
    await remove_item(user_id, item_key, 1)
    return True

def _gif_for(item_key: str) -> Optional[str]:
    return GIFS.get(item_key) or None

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# R√©solution d‚Äôattaques / soins / use
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async def fight(attacker_id: int, target_id: int, item_key: str, guild_id: int, channel_id: int) -> Dict[str, Any]:
    """
    Attaque directe / DOT / attaque en cha√Æne, etc.
    - G√®re poison malus -1 dmg pour l‚Äôattaquant
    - Applique crit (√ó2, mod Zeyra)
    - Applique r√©duction ‚Üí PB ‚Üí PV (via deal_damage)
    - Applique DOTs / infection contagion / virus transfert
    - Ex√©cution du Roi (ignore reduc/PB) ‚Äî voir NOTE
    - Zeyra Undying (1/j) si KO
    """
    it = OBJETS.get(item_key, {})
    t = it.get("type")

    result_lines: List[str] = []
    title = "‚öîÔ∏è Attaque"
    color = COLOR_ATTACK
    consumed = False

    # Validation type
    if t not in {"attaque", "attaque_chaine", "poison", "virus", "infection"}:
        return {"title": "‚ùå Objet d'attaque invalide", "lines": [], "color": 0xFF0000}

    # V√©rifier stock (par s√©curit√©)
    if await get_item_qty(attacker_id, item_key) <= 0:
        return {"title": "‚ùå Plus d‚Äôobjet", "lines": ["Tu n‚Äôas plus cet objet."], "color": 0xFF0000}

    # --- Pr√©paration valeurs ---
    base_dmg = int(it.get("degats", 0))
    crit_chance = float(it.get("crit", 0.0))

    # Poison : malus -1 sur d√©g√¢ts directs
    if await has_status(attacker_id, "poison"):
        base_dmg = max(0, base_dmg - POISON_OUTGOING_PENALTY)

    # Bonus passif vs infect√©s (Kevar Rin +3)
    if await has_status(target_id, "infection"):
        base_dmg += await bonus_damage_vs_infected(attacker_id) or 0

    # Crit
    defender_code = await get_equipped_code(target_id)
    crit_mult = _roll_crit(crit_chance, defender_code)
    dmg_after_crit = int(round(base_dmg * crit_mult))

    # Ex√©cution du Roi (si actif)
    execute = await king_execute_ready(attacker_id, target_id)
    if execute:
        # NOTE: Id√©alement, on doit **ignorer** PB et r√©duction.
        # Selon ton stats_db, si on ne peut pas bypass proprement :
        # on force un tr√®s gros d√©g√¢t et on vide le PB pr√©alablement si tu exposes une API.
        # Ici on fait "brutal" : d√©g√¢ts √©normes -> devrait passer malgr√© r√©duction/PB.
        hp, _ = await get_hp(target_id)
        sh = await get_shield(target_id)
        huge = hp + sh + 9999
        apply_res = await deal_damage(attacker_id, target_id, huge)
        result_lines.append("üëë **Ex√©cution Royale !** (ignore d√©fenses)")
        # Heal +10 PV √† l‚Äôattaquant
        healed = await heal_user(attacker_id, attacker_id, 10)
        if healed > 0:
            result_lines.append(f"‚ù§Ô∏è {healed} PV rendus √† l‚Äôex√©cuteur.")
        consumed = not await maybe_preserve_consumable(attacker_id, item_key)  # ne consomme pas ? (Marn)
        if consumed:
            await remove_item(attacker_id, item_key, 1)
        # KO handling + Undying Zeyra
        if await is_dead(target_id):
            # Zeyra Undying ?
            undy = await undying_zeyra_check_and_mark(target_id)
            if undy:
                # la laisser √† 1 PV
                await revive_full(target_id)  # set to 100, puis on remet 99 d√©g√¢ts
                await deal_damage(0, target_id, 99)
                result_lines.append("üí• **Volont√© de Fracture** : survit √† 1 PV !")
            else:
                await revive_full(target_id)  # r√®gle 14: revive & clear dans les DOT, ici on revive
        return {
            "title": title,
            "lines": result_lines,
            "color": color,
            "gif": _gif_for(item_key),
            "consumed": consumed,
        }

    # --- Cas sp√©ciaux par type ---
    meta = _pack_meta(guild_id, channel_id)

    if t == "poison":
        # DOT poison (ticks g√©r√©s par effects_db) ‚Äî on applique aussi le petit direct ? (non, tu ne l‚Äôas pas demand√©)
        await add_or_refresh_effect(target_id, "poison", int(it.get("degats", 1)), int(it.get("duree", 3600)),
                                    interval=int(it.get("intervalle", 1800)), source_id=attacker_id, meta_json=meta)
        consumed = await _consume_item_if_needed(attacker_id, item_key)
        result_lines.append(f"üß™ {base_dmg} / tick appliqu√© (poison).")
    elif t == "virus":
        # Applique un virus ‚Äúneuf‚Äù
        await add_or_refresh_effect(target_id, "virus", int(it.get("degats", 1)), int(it.get("duree", 3600)),
                                    interval=int(it.get("intervalle", 1800)), source_id=attacker_id, meta_json=meta)
        consumed = await _consume_item_if_needed(attacker_id, item_key)
        result_lines.append("ü¶† Virus appliqu√©.")
    elif t == "infection":
        await add_or_refresh_effect(target_id, "infection", int(it.get("degats", 1)), int(it.get("duree", 3600)),
                                    interval=int(it.get("intervalle", 1800)), source_id=attacker_id, meta_json=meta)
        consumed = await _consume_item_if_needed(attacker_id, item_key)
        result_lines.append("üßü Infection appliqu√©e.")
    elif t == "attaque_chaine":
        # D√©g√¢ts directs sur la cible (principal)
        dmg_main = int(it.get("degats_principal", 0))
        # crit + malus poison d√©j√† calcul√©s via base_dmg si tu veux harmoniser,
        # mais ici on applique crit sur le principal :
        dmg_main = int(round(dmg_main * crit_mult))

        apply = await _apply_direct_damage(attacker_id, target_id, dmg_main)
        consumed = await _consume_item_if_needed(attacker_id, item_key)

        if apply.get("dodged"):
            result_lines.append(ATTACK_DODGE_IMMUNE_LABEL)
        elif apply.get("immune"):
            result_lines.append(IMMUNITY_LABEL)
        else:
            if apply["absorbed"] > 0:
                result_lines.append(f"üõ° {apply['absorbed']} PB absorb√©s.")
            result_lines.append(f"üí• {apply['lost']} d√©g√¢ts inflig√©s (apr√®s r√©ductions).")

        # NOTE: ‚Äúattaque en cha√Æne‚Äù sur d'autres cibles ‚Üí √† impl√©menter plus tard si tu veux
        result_lines.append("‚ò†Ô∏è Attaque en cha√Æne (cible principale).")
    else:
        # t == "attaque" : d√©g√¢ts directs
        apply = await _apply_direct_damage(attacker_id, target_id, dmg_after_crit)
        consumed = await _consume_item_if_needed(attacker_id, item_key)

        if apply.get("dodged"):
            result_lines.append(ATTACK_DODGE_IMMUNE_LABEL)
        elif apply.get("immune"):
            result_lines.append(IMMUNITY_LABEL)
        else:
            if crit_mult > 1.0:
                result_lines.append("üí´ **Coup critique !**")
            if apply["absorbed"] > 0:
                result_lines.append(f"üõ° {apply['absorbed']} PB absorb√©s.")
            result_lines.append(f"üí• {apply['lost']} d√©g√¢ts inflig√©s (apr√®s r√©ductions).")

    # --- Effets secondaires li√©s au statut de l‚ÄôATTAQUANT ---
    # Transfert de virus si l‚Äôattaquant √©tait infect√© par 'virus'
    await transfer_virus_on_attack(attacker_id, target_id, guild_id=guild_id, channel_id=channel_id)

    # Propagation d'infection si l‚Äôattaquant est infect√© (25%)
    if await has_status(attacker_id, "infection"):
        if random.random() < INFECTION_PROPAGATE_CHANCE:
            # Applique une infection ‚Äúcopi√©e‚Äù √† la cible (m√™me gabarit que l‚Äôitem ‚Äòüßü‚Äô)
            # Tu as d√©fini üßü dans OBJETS : on s‚Äôen sert pour la valeur/interval/dur√©e.
            src = OBJETS.get("üßü", {"degats": 5, "intervalle": 1800, "duree": 3 * 3600})
            await add_or_refresh_effect(target_id, "infection", int(src.get("degats", 5)),
                                        int(src.get("duree", 10800)), interval=int(src.get("intervalle", 1800)),
                                        source_id=attacker_id, meta_json=meta)
            # Bonus 5 dmg √† l‚Äôinstant sur la cible si elle devient infect√©e (par ta r√®gle)
            await deal_damage(attacker_id, target_id, 5)
            result_lines.append("üßü Contagion : la cible devient infect√©e (+5 dmg).")

    # KO handling + Zeyra Undying
    if await is_dead(target_id):
        undy = await undying_zeyra_check_and_mark(target_id)
        if undy:
            await revive_full(target_id)
            await deal_damage(0, target_id, 99)  # pour revenir √† 1 PV
            result_lines.append("üí• **Volont√© de Fracture** : survit √† 1 PV !")
        else:
            # R√®gle 14 : √† la mort via ATTAQUE directe ‚Üí on revive √† 100 et clear statuts
            await revive_full(target_id)

    # Triggers post-attaque (loot, vampirisme 50%, etc.)
    await on_attack_after(attacker_id, target_id, item_key)

    return {
        "title": title,
        "lines": result_lines,
        "color": color,
        "gif": _gif_for(item_key),
        "consumed": consumed,
    }


async def heal(healer_id: int, target_id: int, item_key: str, guild_id: int, channel_id: int) -> Dict[str, Any]:
    """
    Soins directs / r√©g√©n√©ration.
    - Les soins ne d√©passent pas PV max (g√©r√© c√¥t√© stats_db)
    - R√©g√©n√©ration : effet 'regen' avec ticks (effects_db)
    - Passifs de soins (Dr Vex +50% re√ßu, Tessa +1 donn√©, Seren ‚Üí PB = soin re√ßu 2x/j, etc.) √† appliquer via hooks on_heal_after
    """
    it = OBJETS.get(item_key, {})
    t = it.get("type")
    result_lines: List[str] = []
    title = "üíä Soin"
    color = COLOR_HEAL
    consumed = False

    if t not in {"soin", "regen"}:
        return {"title": "‚ùå Objet de soin invalide", "lines": [], "color": 0xFF0000}

    if await get_item_qty(healer_id, item_key) <= 0:
        return {"title": "‚ùå Plus d‚Äôobjet", "lines": ["Tu n‚Äôas plus cet objet."], "color": 0xFF0000}

    if t == "soin":
        amount = int(it.get("soin", 0))
        healed = await heal_user(healer_id, target_id, amount)  # stats_db g√®re PV max + √©conomie
        consumed = await _consume_item_if_needed(healer_id, item_key)

        if healed <= 0:
            result_lines.append("‚ÑπÔ∏è Aucun PV soign√© (d√©j√† au max ?).")
        else:
            result_lines.append(f"‚ù§Ô∏è +{healed} PV.")

    else:  # regen
        meta = _pack_meta(guild_id, channel_id)
        await add_or_refresh_effect(
            target_id,
            "regen",
            float(it.get("valeur", 1)),
            int(it.get("duree", 3600)),
            interval=int(it.get("intervalle", 1800)),
            source_id=healer_id,
            meta_json=meta
        )
        consumed = await _consume_item_if_needed(healer_id, item_key)
        result_lines.append("üíï R√©g√©n√©ration appliqu√©e.")

    # Triggers post-heal (Lysha PB+1, Seren PB=soin 2x/j, etc.)
    await on_heal_after(healer_id, target_id, item_key)

    return {
        "title": title,
        "lines": result_lines,
        "color": color,
        "gif": _gif_for(item_key),
        "consumed": consumed,
    }


async def use_item(user_id: int, target_id: int, item_key: str, guild_id: int, channel_id: int) -> Dict[str, Any]:
    """
    Utilisation d‚Äôobjets non offensifs :
      - bouclier (cap 20 par d√©faut, 25 si passif Raya, g√©r√© c√¥t√© stats_db si expos√©)
      - vaccin (retire poison + virus)
      - vol (ne peut pas voler les tickets ‚Äî √† v√©rifier c√¥t√© inventaire/cl√©)
      - immunit√©, esquive+, r√©duction (temp), mysterybox (loot)
    """
    it = OBJETS.get(item_key, {})
    t = it.get("type")
    result_lines: List[str] = []
    title = "üß∞ Utilisation"
    color = COLOR_USE
    consumed = False

    if t not in {"bouclier", "vaccin", "vol", "immunite", "esquive+", "reduction", "mysterybox"}:
        return {"title": "‚ùå Objet non-utilisable invalide", "lines": [], "color": 0xFF0000}

    if await get_item_qty(user_id, item_key) <= 0:
        return {"title": "‚ùå Plus d‚Äôobjet", "lines": ["Tu n‚Äôas plus cet objet."], "color": 0xFF0000}

    meta = _pack_meta(guild_id, channel_id)

    if t == "bouclier":
        val = int(it.get("valeur", 0))
        gained = await add_shield(target_id, val)  # stats_db doit plafonner √† 20 (ou 25 si passif active le cap)
        consumed = await _consume_item_if_needed(user_id, item_key)
        result_lines.append(f"üõ° +{gained} PB appliqu√©s.")

    elif t == "vaccin":
        # retire poison & virus (et, par ton update, **infection** aussi ? Tu as dit finalement ‚Äúvaccin retire l‚Äôinfection‚Äù)
        await remove_status(target_id, "poison")
        await remove_status(target_id, "virus")
        await remove_status(target_id, "infection")
        consumed = await _consume_item_if_needed(user_id, item_key)
        result_lines.append("üíâ Vaccination : statuts supprim√©s (poison, virus, infection).")

    elif t == "vol":
        # Vol d‚Äôun item al√©atoire (sauf tickets) ‚Äî simplifi√©
        # On va essayer de voler dans une whitelist d‚Äôemojis d‚ÄôOBJETS sans üéüÔ∏è
        stealable = [k for k in OBJETS.keys() if k != "üéüÔ∏è"]
        if not stealable:
            return {"title": "‚ÑπÔ∏è Rien √† voler", "lines": [], "color": 0xAAAAAA}
        choice = random.choice(stealable)
        have = await get_item_qty(target_id, choice)
        if have <= 0:
            result_lines.append("üïµÔ∏è Rien d‚Äôutile n‚Äôa √©t√© trouv√©.")
        else:
            await remove_item(target_id, choice, 1)
            await add_item(user_id, choice, 1)
            result_lines.append(f"üïµÔ∏è Vol r√©ussi : {choice}")
        consumed = await _consume_item_if_needed(user_id, item_key)

    elif t == "immunite":
        await add_or_refresh_effect(target_id, "immunite", 1.0, int(it.get("duree", 2*3600)), interval=0, source_id=user_id, meta_json=meta)
        consumed = await _consume_item_if_needed(user_id, item_key)
        result_lines.append("‚≠ê Immunit√© temporaire appliqu√©e.")

    elif t == "esquive+":
        await add_or_refresh_effect(target_id, "esquive", float(it.get("valeur", 0.2)), int(it.get("duree", 3*3600)), interval=0, source_id=user_id, meta_json=meta)
        consumed = await _consume_item_if_needed(user_id, item_key)
        result_lines.append("üëü Esquive augment√©e temporairement.")

    elif t == "reduction":
        await add_or_refresh_effect(target_id, "reduction_temp", float(it.get("valeur", 0.5)), int(it.get("duree", 4*3600)), interval=0, source_id=user_id, meta_json=meta)
        consumed = await _consume_item_if_needed(user_id, item_key)
        result_lines.append("ü™ñ R√©duction des d√©g√¢ts temporaire appliqu√©e.")

    elif t == "mysterybox":
        # Simple exemple : donne 1‚Äì3 objets al√©atoires (sauf üéüÔ∏è) OU des tickets
        pulls = random.randint(1, 3)
        pool = [k for k in OBJETS.keys() if k != "üéüÔ∏è"]
        won: Dict[str, int] = {}
        for _ in range(pulls):
            k = random.choice(pool)
            won[k] = won.get(k, 0) + 1
        for k, q in won.items():
            await add_item(user_id, k, q)
        consumed = await _consume_item_if_needed(user_id, item_key)
        pretty = " ".join(f"{k} x{q}" for k, q in won.items())
        result_lines.append(f"üì¶ {pretty}")

    # Triggers post-use (si utiles)
    await on_use_after(user_id, target_id, item_key)

    return {
        "title": title,
        "lines": result_lines,
        "color": color,
        "gif": _gif_for(item_key),
        "consumed": consumed,
    }
